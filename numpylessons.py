# -*- coding: utf-8 -*-
"""NumpyLessons.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OG9JoOhU1Ej7KgR581iWOFs40EVNrDSo
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Helpful tip
# to see the syntax of a function, type: ctrl+tab

# Creating an auto-generated/sorted array

# 0 to 10 (inclusive)
ex_1 = np.arange(0,11)
print(ex_1)
print('\n')

# 0 to 10 (inclusive), but counted by 2s
ex_2 = np.arange(0, 11, 2) 
print(ex_2)

# Diff between Python list matrix and np array matrix

list = [[1,2,3], [4,5,6], [7,8,9]]

np_list = np.array([[1,2,3], [4,5,6], [7,8,9]]) 

print(list)
print('\n')
print(np_list)

"""##Array of zeros and ones"""

from numpy.core.numeric import zeros_like
# Generating an array of all zeros and ones

# Vector of zeros
zeros = np.zeros(3)
print(zeros)
print('\n') 

# 5 x 5 Matrix of zeros
zeros_matrix = np.zeros((5,5)) 
print(zeros_matrix)
print('\n')

# Vector of ones
ones = np.ones(3)
print(ones)
print('\n') 

# 5 x 5 Matrix of ones
ones_matrix = np.ones((5,5)) 
print(ones_matrix)

"""##Linspace"""

# Linspace
# Creats an array with evenly spaced numbers
# starting point: 0, ending point: 100, number of elements wanted: 5
# there will be 5 elements to count from 0 to 100 that will be evenly spaced; in this case, there will be 25 between each point.
# so np.linspace(start = 0, stop = 100, num = 5):
# Stars at 0, goes to 100, with 5 items including 0 and 100
# so 0, 25, 50, 75, 100
# Just providing an even space for each item in the array 
# This will just return an array with evenly spaced elements

# Ex 1
# np.linspace(0,5,100)
# returns 100 evenly spaced points counting from 0 to 5

# Ex 2
# np.linspace(start = 0, stop = 1, num = 11) produces:
# array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1. ])

"""##np.eye() function"""

# Random but useful
# np.eye() is a 2D square Matrix 
# Means number of rows is same number of columns
# You have a diagnol set of 1s
# Rest are zeros 

# Ex 1
np.eye(4) 

# Outputs:
# array([[1., 0., 0., 0.],
#        [0., 1., 0., 0.],
#        [0., 0., 1., 0.],
#        [0., 0., 0., 1.]])

"""##Creating Random Numbers"""

# Typing np.random will populate a bunch of options to choose from. We will just cover basic ones

# One dimensional vector of random numbers
one_d = np.random.rand(5) 
print(one_d)
print('\n')

# Unlike previous stuff you don't pass in a tuple for matricies
# Pass in the dimensions as separate args
# Additional rand option called randn
# randn are not unfiform distributions. Instead they are standard normal distributions centered around 0
two_d = np.random.randn(5,5) 
print(two_d)
print('\n')

# rand int function returns integers from a low to a high number
# following line will produce rand int between 1 and 99 technically
# if you want a particular number of rand integers printed, add 3rd argument: rand_int_ex = np.random.randint(1,100,10)

rand_int_ex = np.random.randint(1,100) # low is inclusive and high is exclusive
print(rand_int_ex)

"""##Useful Methods you Can Use on Arrays!"""

# Reshape method
# Returns an array with same data but a new shape

# # Ex 1
# ranarr = np.random.randint(0,50,10)
# print(ranarr)
# print('\n')

# Reshaping ranarr 
# You will get an error if you can't fill up matrix completely
arr = np.arange(25)
arr.reshape(5,5)

"""##Useful Operations"""

# ranarr.min()
# ranarr
# ranarr.max()
# ranarr.argmax() returns index of max 
# ranarr.argmin() returns index of min 
# arr.shape
# arr.reshape
# arr.dtype to see type of data

"""##Numpy Array Indexing"""

# Ex array
new_arr = np.arange(0,11)
new_arr

# Indexing

# Single index
new_arr[8] 

# Range index using slice notation(starting and ending index)
new_arr[1:5] # from index 1 to 4 since 5 is not included 

# getting everything up to a specific index
new_arr[:6] # which is the same as the next line but with less typing
new_arr[0:6]  

# getting everything after an index
new_arr[5:] 

# assigning or broadcasting values to array indicies
new_arr[0:5] = 100

"""## Copying arrays or DFs"""

# Super important!
# Creating a variable that houses original array or data set will not stop it from being changed
# You must create a copy if you want to make changes w/o affecting original

"""## Matricies"""

arr_2D = np.array([[5,10,15], [20,25,30], [35,40,45]]) 
arr_2D

# # Accessing Matrix Elements with slicing

# # Double bracket notation

# # row 1 column 1
# arr_2D[0][0] 

# # row 1
# arr_2D[0] 

# # row 3 col 2
# arr_2D[2][1]

# # row 2 col 3
# arr_2D[1][2]

# # Single bracket notation

# # row 3 col 2
# arr_2D[2,1] 

# # row 2 col 3
# arr_2D[1,2] 

# Colon Notation

# eveything to row 3 (row3 not included), everything after col 2 (col2 included)
# Output should be row 1 and 2, and col 2 and 3
# row 1 & 2 col 2 & 3
# arr_2D[:2,1:] # recall that number on the right of colon is not included, but number on left is included
              # in other words, start point is included, but end is not
              # see output if you get confused 

# rows 1 and 2
# indx 0 and 1
arr_2D[:2] # see output if you get confused

"""## Applying Operators to Arrays"""

# Example Array
arr = np.arange(1,11)
arr

# Checking array for vals greater than 5
# This will return booleans for condition satisfied or not at each index
# arr > 5

# If you want the results w/o boolean 
# bool_arr = arr > 5
# arr[bool_arr] 

# Or
arr[arr>5]

# Creating an arranged array, and reshaping it as a matrix in one-line
# 5 by 10 matrix with elements going from 0 to 50 (50 not included)
# See output for visualization

arr_2d = np.arange(50).reshape(5,10) 
arr_2d 

# indexing array

# rows 2 & 3 (4 not included)
# indx 1 & 2 (3 not included)
arr_2d[1:3]

"""##Numpy Operations 


*   Array with Array
*   Array with Scalars
*   Universal Array Functions


"""

# Example Array
arr = np.arange(0,11)
arr

# Addiing arrays
arr + arr 

# Subtracting arrays 
arr - arr 

# Multiplying arrays 
arr * arr 

# Adding a number to each element in array
arr + 100 

# Multiplying by a number to each element in array
arr * 100 

# Subtracting a number from each element in array
arr - 100

# Arrays with Scalars

# dividing by 0 
# Recall anything divided by 0 will give an error
# However, an np/0 will still run, and just produce a 'nan' value
# arr/arr Will give you all array elements divided by one another. Where index val is 0 will give you nan 
# same for 1/arr 
# FINAL NOTE: keep an eye out for zeros in array. They will affect a lot of mathematical functions beyond division

# Exponents
# every element in array with exp of 2 applied
arr**2 

# Square root
# Taking the root of every element
np.sqrt(arr) 

# Calculating exponential
np.exp(arr) 

# sin function for each element
np.sin(arr) 

# log function of each element
np.log(arr)



















































